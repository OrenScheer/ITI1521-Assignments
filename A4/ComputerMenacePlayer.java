import java.util.LinkedList;


public class ComputerMenacePlayer extends Player {

	// YOUR CODE HERE
  private LinkedList<LinkedList<MenaceTicTacToeGame>> allGames;
  private static final int[] beadAmounts = new int[]{8, 8, 4, 4, 2, 2, 1, 1, 1}; // Keep track of how many beads should be assigned to each move based on the level of the game
  private LinkedList<MenaceTicTacToeGame> currentMoveSequence; // Keep track of the current move sequence, or the "matchbox drawers open"

  /**
  * Constructor that generates all MENACE's game possibilities
  * and assigns them beads based on predetermined amounts.
  */
  public ComputerMenacePlayer() {
    super();

    allGames = new LinkedList<LinkedList<MenaceTicTacToeGame>>();

		// start with the empty game
		allGames.add(new LinkedList<MenaceTicTacToeGame>());
		allGames.get(0).add(new MenaceTicTacToeGame());

		// build the new games by adding the next moves to the
		// previously built games
		for(int i=1; i<= 9; i++) {
			LinkedList<MenaceTicTacToeGame> newList;
			newList = new LinkedList<MenaceTicTacToeGame>();
			allGames.add(newList);
			for(MenaceTicTacToeGame game: allGames.get(i-1)){
				if(game.getGameState() == GameState.PLAYING) {
          				LinkedList<MenaceTicTacToeGame> temp = new LinkedList<MenaceTicTacToeGame>(); // Also keep track of the games generated by the current base
					for(int j = 0; j < 9; j++) {
						if(game.valueAt(j) == CellValue.EMPTY) {
							MenaceTicTacToeGame newGame = new MenaceTicTacToeGame(game,j);
              						boolean isNewThisBase = true; // Is it symmetrical to one already created from this base?
							boolean isNewWholeList = true; // Is it symmetrical to one already created on this level from a different base?
              						for (MenaceTicTacToeGame previousGame: temp) { // First check if it's symmetrical to one already created from this base
               							 if (newGame.equalsWithSymmetry(previousGame)) { // If it is, it won't be included in allGames, and beads won't be added to the base at index j
                							isNewThisBase = false; // This way, we account for symmetry when assigning beads
                  							isNewWholeList = false; // Some games won't be added to allGames since they're already there, but beads still need to be assigned to their base game
                  							break;
                						}
             					 	}
              						if (isNewThisBase) { // If it is new this base
                						temp.add(newGame); // Add it to the list of games generated from the base game
                						game.addBeadsAt(j, beadAmounts[game.getLevel()]); // Add beads to the base game at the position j
  								for(MenaceTicTacToeGame existingGame: allGames.get(i)){ // Still have to check if it's new on the whole list though
  									if(newGame.equalsWithSymmetry(existingGame)){
  										isNewWholeList = false;
  										break;
  									}
								}
              						}
							if(isNewWholeList) { // If it is, only then do we add it to allGames
								newList.add(newGame);
							}
						}
					}
				}
			}
		}
  }

  /**
  *  Overrides startNewGame() of parent class.
  *  @param myMove
  *   the symbol being played by MENACE
  */
  public void startNewGame(CellValue myMove){
		super.startNewGame(myMove); // Call parent method
    		currentMoveSequence = new LinkedList<MenaceTicTacToeGame>(); // Each time a game starts, we create a new LinkedList to represent the current sequence of boards played by MENACE
	}

  /**
  *  Implements play() of the parent class.
  *  @param game
  *   a reference to the game on which MENACE will play
  */
  public void play (TicTacToeGame game) {
  	if(game.getLevel() == game.lines*game.columns){
		throw new IllegalArgumentException("Game is finished already!");
	}

    	for(MenaceTicTacToeGame menaceGame: allGames.get(game.getLevel())) { // Look through MENACE's stored games at the appropriate level
			if(menaceGame.equalsWithSymmetry(game)) {
				game.play(menaceGame.chooseMove()); // MenaceTicTacToeGame has a method to choose the next move based on the beads
        			currentMoveSequence.add(menaceGame); // Add a reference to this game to the list of the move sequence
				return;
			}
		}

    	throw new IllegalStateException("Game not found: " + game); // If not found (shouldn't happen)
  }

  /**
  * Overrides gameFinished() of the parent class.
  * @param result
  *   the end state of the game just finished
  */
  public void gameFinished(GameState result) {
    super.gameFinished(result); // Call parent method
    if (result == GameState.XWIN) {
      if (myMove == CellValue.O) {
        lost();
      } else if (myMove == CellValue.X) {
        won();
      }
    } else if (result == GameState.OWIN) {
      if (myMove == CellValue.X) {
        lost();
      } else if (myMove == CellValue.O) {
        won();
      }
    } else { // Would have already thrown exception in super.gameFinished(result) if result was GameState.PLAYING
      drew();
    }
  }

  /**
  * Helper method to assign beads if MENACE lost the game.
  */
  private void lost() {
    for (MenaceTicTacToeGame played: currentMoveSequence) {
      if (played.getNumBeads() > 1) { // There will never be 0 beads in a game
        played.removeBeadsAt(played.getCellPlayed(), 1); // Remove a bead from the cell where MENACE
      }
    }
  }

  /**
  * Helper method to assign beads if MENACE won the game.
  */
  private void won() {
    for (MenaceTicTacToeGame played: currentMoveSequence) {
      played.addBeadsAt(played.getCellPlayed(), 3); // Add three beads to the cell where MENACE played
    }
  }

  /**
  * Helper method to assign beads if MENACE drew the game.
  */
  private void drew() {
    for (MenaceTicTacToeGame played: currentMoveSequence) {
      played.addBeadsAt(played.getCellPlayed(), 1); // Add one bead to the cell where MENACE played
    }
  }

}
